# PROJECT DUMP FOR LLM / CODE REVIEW

Generated at: 2025-12-09T22:56:36Z
Project root: /home/placerte/projects/project-dumper

Document structure:
1. This header section (what you are reading now).
2. A directory tree of the project (if enabled).
3. The contents of each included file, in deterministic order.

Conventions:
- Each file starts with a header line like:
    ==== FILE: relative/path/to/file.py ==== 
- File contents follow immediately after the header.

LLM instructions (suggested):
- Treat this as a *read-only* snapshot of the project.
- When referencing code, mention the file path and line(s) if possible.
- If you propose changes, explain them in terms of specific files/sections.

Filtering applied:
- Excluded directory names: ['.git', '.hg', '.idea', '.mypy_cache', '.pytest_cache', '.svn', '.venv', '.vscode', '__pycache__', 'build', 'dist', 'node_modules', 'venv']
- Excluded file extensions: ['.7z', '.avi', '.bin', '.dll', '.dylib', '.exe', '.gif', '.gz', '.ico', '.jpeg', '.jpg', '.mkv', '.mov', '.mp3', '.mp4', '.o', '.obj', '.otf', '.pdf', '.png', '.pyc', '.pyo', '.so', '.tar', '.ttf', '.webp', '.woff', '.woff2', '.xz', '.zip']
- Included extensions: ALL non-binary files (minus excluded ext).

================================================================================

DIRECTORY TREE
--------------------------------------------------------------------------------
project-dumper
├── .git
├── .venv
├── __pycache__
├── src
│   ├── project_dumper
│   │   ├── __pycache__
│   │   ├── __init__.py
│   │   ├── cli.py
│   │   ├── constants.py
│   │   ├── files.py
│   │   ├── header.py
│   │   └── tree.py
│   └── project_dumper.egg-info
│       ├── dependency_links.txt
│       ├── entry_points.txt
│       ├── PKG-INFO
│       ├── SOURCES.txt
│       └── top_level.txt
├── .gitignore
├── .python-version
├── pyproject.toml
├── README.md
└── uv.lock

================================================================================


FILES INCLUDED
--------------------------------------------------------------------------------
.gitignore
.python-version
README.md
pyproject.toml
src/project_dumper.egg-info/PKG-INFO
src/project_dumper.egg-info/SOURCES.txt
src/project_dumper.egg-info/dependency_links.txt
src/project_dumper.egg-info/entry_points.txt
src/project_dumper.egg-info/top_level.txt
src/project_dumper/__init__.py
src/project_dumper/cli.py
src/project_dumper/constants.py
src/project_dumper/files.py
src/project_dumper/header.py
src/project_dumper/tree.py
uv.lock

================================================================================

==== FILE: .gitignore ====

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/


==== FILE: .python-version ====

3.13


==== FILE: README.md ====

# project-dumper
A python project flattener that exports small projects to a single txt file.


==== FILE: pyproject.toml ====

[project]
name = "project-dumper"
version = "0.1.0"
description = "Dump a project into a single LLM-friendly text file"
requires-python = ">=3.11"
dependencies = []

[project.scripts]
project-dumper = "project_dumper.cli:main"
produm = "project_dumper.cli:main"

[tool.uv]
package = true



==== FILE: src/project_dumper.egg-info/PKG-INFO ====

Metadata-Version: 2.4
Name: project-dumper
Version: 0.1.0
Summary: Dump a project into a single LLM-friendly text file
Requires-Python: >=3.11


==== FILE: src/project_dumper.egg-info/SOURCES.txt ====

README.md
pyproject.toml
src/project_dumper/__init__.py
src/project_dumper/cli.py
src/project_dumper/constants.py
src/project_dumper/files.py
src/project_dumper/header.py
src/project_dumper/tree.py
src/project_dumper.egg-info/PKG-INFO
src/project_dumper.egg-info/SOURCES.txt
src/project_dumper.egg-info/dependency_links.txt
src/project_dumper.egg-info/entry_points.txt
src/project_dumper.egg-info/top_level.txt

==== FILE: src/project_dumper.egg-info/dependency_links.txt ====




==== FILE: src/project_dumper.egg-info/entry_points.txt ====

[console_scripts]
produm = project_dumper.cli:main
project-dumper = project_dumper.cli:main


==== FILE: src/project_dumper.egg-info/top_level.txt ====

project_dumper


==== FILE: src/project_dumper/__init__.py ====

from __future__ import annotations

__all__ = ["__version__"]

__version__ = "0.1.0"



==== FILE: src/project_dumper/cli.py ====

from __future__ import annotations

import argparse
from pathlib import Path
from typing import List, Set

from project_dumper.constants import (
    DEFAULT_EXCLUDE_DIRS,
    DEFAULT_EXCLUDE_EXTS,
    DEFAULT_MAX_BYTES,
)
from project_dumper.files import iter_files, read_text_file, add_line_numbers
from project_dumper.header import format_header
from project_dumper.tree import build_dir_tree


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Dump a project into a single, LLM-friendly text file."
    )
    parser.add_argument(
        "root",
        nargs="?",
        default=".",
        help="Root directory of the project (default: current directory).",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="project_dump.txt",
        help="Output text file (default: project_dump.txt).",
    )
    parser.add_argument(
        "--include-ext",
        nargs="*",
        default=None,
        metavar="EXT",
        help=(
            "Only include files with these extensions (e.g. --include-ext .py .md .txt). "
            "If omitted, includes all non-binary files except excluded extensions."
        ),
    )
    parser.add_argument(
        "--exclude-dir",
        nargs="*",
        default=[],
        metavar="DIR",
        help="Additional directory names to exclude (on top of built-in defaults).",
    )
    parser.add_argument(
        "--exclude-ext",
        nargs="*",
        default=[],
        metavar="EXT",
        help="Additional file extensions to exclude (on top of built-in defaults).",
    )
    parser.add_argument(
        "--max-bytes",
        type=int,
        default=DEFAULT_MAX_BYTES,
        help=f"Skip files larger than this size in bytes (default: {DEFAULT_MAX_BYTES:,}).",
    )
    parser.add_argument(
        "--no-tree",
        action="store_true",
        help="Do not include the directory tree in the output.",
    )
    parser.add_argument(
        "--with-line-numbers",
        action="store_true",
        help="Include line numbers in file contents.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    root = Path(args.root).resolve()
    output = Path(args.output)

    if not root.exists() or not root.is_dir():
        raise SystemExit(f"Root path does not exist or is not a directory: {root}")

    exclude_dirs: Set[str] = set(DEFAULT_EXCLUDE_DIRS) | set(args.exclude_dir)
    exclude_exts: Set[str] = set(DEFAULT_EXCLUDE_EXTS) | {e.lower() for e in args.exclude_ext}
    include_exts: Set[str] | None = (
        {e.lower() for e in args.include_ext} if args.include_ext is not None else None
    )

    files = sorted(
        iter_files(root, exclude_dirs, exclude_exts, include_exts, args.max_bytes),
        key=lambda p: str(p.relative_to(root)),
    )

    header = format_header(root, include_exts, exclude_dirs, exclude_exts)

    tree_str = ""
    if not args.no_tree:
        tree_str = "DIRECTORY TREE\n" + "-" * 80 + "\n"
        tree_str += build_dir_tree(root, exclude_dirs)
        tree_str += "\n\n" + "=" * 80 + "\n\n"

    result_lines: List[str] = []
    result_lines.append(header)
    if tree_str:
        result_lines.append(tree_str)

    # Files section summary
    result_lines.append("FILES INCLUDED")
    result_lines.append("-" * 80)
    for f in files:
        rel = f.relative_to(root)
        result_lines.append(str(rel))
    result_lines.append("")
    result_lines.append("=" * 80)
    result_lines.append("")

    # Now dump each file with its own header + contents
    for f in files:
        rel = f.relative_to(root)
        result_lines.append(f"==== FILE: {rel} ====")
        result_lines.append("")
        content = read_text_file(f)
        if args.with_line_numbers:
            content = add_line_numbers(content)
        result_lines.append(content)
        result_lines.append("")  # blank line between files

    text = "\n".join(result_lines)

    try:
        output.write_text(text, encoding="utf-8")
    except OSError as e:
        raise SystemExit(f"Error writing output file {output}: {e}")

    print(f"Wrote dump for {len(files)} files to {output}")


if __name__ == "__main__":
    main()



==== FILE: src/project_dumper/constants.py ====

from __future__ import annotations

from typing import Set

# Directories we don't want to descend into by default.
DEFAULT_EXCLUDE_DIRS: Set[str] = {
    ".git",
    ".hg",
    ".svn",
    ".idea",
    ".vscode",
    "__pycache__",
    ".mypy_cache",
    ".pytest_cache",
    "node_modules",
    "dist",
    "build",
    ".venv",
    "venv",
}

# File extensions that are usually binary / not useful for LLM context.
DEFAULT_EXCLUDE_EXTS: Set[str] = {
    ".pyc",
    ".pyo",
    ".so",
    ".dll",
    ".dylib",
    ".exe",
    ".bin",
    ".obj",
    ".o",
    ".pdf",
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".webp",
    ".ico",
    ".ttf",
    ".otf",
    ".woff",
    ".woff2",
    ".zip",
    ".tar",
    ".gz",
    ".xz",
    ".7z",
    ".mp3",
    ".mp4",
    ".mov",
    ".avi",
    ".mkv",
}

# Default maximum file size to include (in bytes).
DEFAULT_MAX_BYTES: int = 2_000_000

# Number of bytes sampled when detecting binary files.
BINARY_DETECTION_SAMPLE_SIZE: int = 8_000



==== FILE: src/project_dumper/files.py ====

from __future__ import annotations

import os
from pathlib import Path
from typing import Iterable, List, Set

from .constants import BINARY_DETECTION_SAMPLE_SIZE


def is_probably_binary(path: Path, sample_size: int = BINARY_DETECTION_SAMPLE_SIZE) -> bool:
    """
    Heuristic: if the sampled bytes contain NUL, treat as binary.
    """
    try:
        with path.open("rb") as f:
            chunk = f.read(sample_size)
        if b"\x00" in chunk:
            return True
        return False
    except OSError:
        # If we can't read it, treat it as binary/unwanted
        return True


def iter_files(
    root: Path,
    exclude_dirs: Set[str],
    exclude_exts: Set[str],
    include_exts: Set[str] | None,
    max_bytes: int,
) -> Iterable[Path]:
    """
    Walk the project tree and yield files that match filtering rules.
    """
    root = root.resolve()
    for dirpath, dirnames, filenames in os.walk(root):
        # Filter directories in-place so os.walk doesn't descend into them
        dirnames[:] = [d for d in dirnames if d not in exclude_dirs]

        for name in filenames:
            path = Path(dirpath) / name
            ext = path.suffix.lower()

            if include_exts is not None and ext not in include_exts:
                continue

            if ext in exclude_exts:
                continue

            try:
                size = path.stat().st_size
            except OSError:
                continue

            if size > max_bytes:
                continue

            if is_probably_binary(path):
                continue

            yield path


def read_text_file(path: Path) -> str:
    """Read a text file with utf-8 + replacement fallback."""
    try:
        return path.read_text(encoding="utf-8", errors="replace")
    except OSError:
        return f"<<ERROR: could not read file {path}>>"


def add_line_numbers(text: str, start: int = 1) -> str:
    """
    Prefix each line with a line number.
    """
    lines = text.splitlines()
    width = len(str(start + len(lines) - 1))
    numbered: List[str] = [
        f"{str(i).rjust(width)} | {line}" for i, line in enumerate(lines, start)
    ]
    return "\n".join(numbered)



==== FILE: src/project_dumper/header.py ====

from __future__ import annotations

import datetime as dt
from pathlib import Path
from typing import Set


def format_header(
    root: Path,
    include_exts: Set[str] | None,
    exclude_dirs: Set[str],
    exclude_exts: Set[str],
) -> str:
    """
    Build the top-of-file header that explains structure + instructions for the LLM.
    """
    now = dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"
    lines = [
        "# PROJECT DUMP FOR LLM / CODE REVIEW",
        "",
        f"Generated at: {now}",
        f"Project root: {root.resolve()}",
        "",
        "Document structure:",
        "1. This header section (what you are reading now).",
        "2. A directory tree of the project (if enabled).",
        "3. The contents of each included file, in deterministic order.",
        "",
        "Conventions:",
        "- Each file starts with a header line like:",
        "    ==== FILE: relative/path/to/file.py ==== ",
        "- File contents follow immediately after the header.",
        "",
        "LLM instructions (suggested):",
        "- Treat this as a *read-only* snapshot of the project.",
        "- When referencing code, mention the file path and line(s) if possible.",
        "- If you propose changes, explain them in terms of specific files/sections.",
        "",
        "Filtering applied:",
        f"- Excluded directory names: {sorted(exclude_dirs)}",
        f"- Excluded file extensions: {sorted(exclude_exts)}",
    ]
    if include_exts is None:
        lines.append("- Included extensions: ALL non-binary files (minus excluded ext).")
    else:
        lines.append(f"- Included extensions (whitelist): {sorted(include_exts)}")

    lines.append("")
    lines.append("=" * 80)
    lines.append("")
    return "\n".join(lines)



==== FILE: src/project_dumper/tree.py ====

from __future__ import annotations

from pathlib import Path
from typing import List, Set


def build_dir_tree(root: Path, exclude_dirs: Set[str]) -> str:
    """
    Build a simple ASCII tree of directories and files under `root`,
    skipping any directory whose name is in `exclude_dirs`.
    """
    lines: List[str] = []

    root = root.resolve()
    root_name = root.name or str(root)

    lines.append(root_name)

    def walk(dir_path: Path, prefix: str = "") -> None:
        entries = sorted(
            [p for p in dir_path.iterdir()],
            key=lambda p: (p.is_file(), p.name.lower()),
        )
        total = len(entries)
        for idx, entry in enumerate(entries):
            is_last = idx == total - 1
            connector = "└── " if is_last else "├── "
            line = f"{prefix}{connector}{entry.name}"
            lines.append(line)
            if entry.is_dir() and entry.name not in exclude_dirs:
                new_prefix = prefix + ("    " if is_last else "│   ")
                walk(entry, new_prefix)

    walk(root)
    return "\n".join(lines)



==== FILE: uv.lock ====

version = 1
revision = 3
requires-python = ">=3.11"

[[package]]
name = "project-dumper"
version = "0.1.0"
source = { editable = "." }

